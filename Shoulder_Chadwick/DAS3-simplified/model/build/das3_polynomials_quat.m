function das3_polynomials_quat(osimfile,mydir,musclepolyfile)
model = das3_readosim(osimfile);
muscles = model.muscles;
% Based on pathpoly.m by Ton van den Bogert
%
% Computes best fitting polynomial for muscle-tendon length L as a function
% of kinematic degrees of freedom q.
%
% This is done from moment arms generated by Opensim, using the relationship
% <momentarm of muscle m with respect to dof q> = -dLm/dq
%
% Stopping criteria: either error < 10% of maximum moment arm or 2mm, 
% whichever is greater, or change in error < 5% of error 
%
% input: structure "muscles", created by "das3_readosim.m"
%
% The moment arms and lengths are read from .mat files named: 
% "path_<muscle name>.mat", e.g. "path_bic_l.mat"
% 
% The polynomials are written in files: "<musclepolyfile>.mat" and
% "<musclepolyfile>.txt"
%
% Dimitra Blana, December 2011
%
% UPDATE June 18 2012: both lengths and moment arms are fitted (not just
% moment arms), and at least one term that includes every degree of freedom
% the muscle crosses is required.
%
% UPDATE August 2nd 2012: instead of including at least one term for each
% dof, the equations for each dof are *scaled* to the maximum moment arm/length 
% Also, the constant term of the polynomial is estimated as well.

%% open files and read in moment arms
format long;			% so we get full precision output for polynomial coefficients

% log file (output)
logfilename = [mydir '\pathpoly.log'];
logfile = fopen(logfilename,'w');
if (logfile < 0)
    errordlg(['Could not open log file ',logfilename,' for writing'],'File Error');
    fclose('all');
    return;
end

% results file (output)
polyfilename = [mydir '\' musclepolyfile '.txt'];
polyfile = fopen(polyfilename,'w');
if (polyfile < 0)
    errordlg(['Could not open results file ',polyfilename,' for writing'],'File Error');
    fclose('all');
    return;
end

% mat file, if it exists, append, don't overwrite
matfilename = [mydir '\' musclepolyfile '.mat'];
if exist(matfilename,'file')
    polys = load(matfilename);
    mus_model = polys.mus_model;
end

%% main loop for each muscle element
for imus = 1:length(muscles)
    
    % get moment arms and lengths out of the .mat files
    musfilename = [mydir,'\path_',muscles{imus}.name,'.mat'];
    ma = load(musfilename);
        
    mus = muscles{1,imus};
    ndofs = length(mus.dof_indeces); % number of dofs spanned by this muscle
    order = 4; % polynomial order
        
    num_data = size(ma.alljnts,1);
    
    % count how many parameters the polynomial model for muscle length has
    npar = prod(1:ndofs+order)/prod(1:ndofs)/prod(1:order);
    fprintf(1,'Muscle name:      %s\n',mus.name);
    fprintf(1,'Number of DOFs:   %d\n',ndofs);
    fprintf(1,'Polynomial order: %d\n',order);
    fprintf(1,'Potential number of polynomial terms: %d\n',npar);
    tot_data = num_data*(ndofs+1);	% total number of data points
    A = zeros(tot_data, npar);      % allocate memory space for A
    b = zeros(tot_data, 1);         % allocate memory space for b

    % get angle values for the dofs the muscle crosses
    musdof_indeces = zeros(ndofs,1);
    for idof = 1:ndofs
        imusdof = mus.dof_indeces(idof);
        musdof_indeces(idof) = imusdof;
    end
    ang = (ma.alljntsQA(:,musdof_indeces));	% protect against angle = 0.0
   
    maxmomdof = zeros(1,ndofs);
    for idof = 1:ndofs
        maxmomdof(idof) = max(abs(ma.quat_J(:,idof)))*1000;
    end    
    maxall = max(maxmomdof);
    % this normalises all moment arms
    ml_weight = (maxmomdof)/maxall;
    % Stopping criterion: error less than 10% of maximum moment arm (in mm) 
    % for the muscle or 2mm, whichever is greater
    momarm_error = max(0.1*maxall,2); 
    % momarm_error = 0.01*maxall; 

    for idof = 1:ndofs
        % read moment arm from allmomarms matrix
        % and angles from alljnts matrix
        b((idof-1)*num_data+1:idof*num_data) = -ma.quat_J(:,idof)/ml_weight(idof);
        
        % generate the npar polynomial terms, and for each term, add a column to A
        polylist = zeros(npar,ndofs);
        expon = zeros(num_data,ndofs);	% start with all exponents zero
        for ii=1:npar
            polylist(ii,:) = expon(1,:);
            A((idof-1)*num_data+1:idof*num_data,ii) = (expon(:,idof).*prod(ang.^expon,2)./ang(:,idof))/ml_weight(idof); % contribution of this term to moment arm idof
            % generate the next set of exponents, but remain within model order
            k = 1;
            while (1)
                expon(:,k) = expon(:,k)+1;
                if (sum(expon(1,:)) > order && ii<npar)
                    expon(:,k)=0;
                    k = k+1;
                else
                    break;
                end
            end
        end     % done generating model terms
    end		% done reading all data for this muscle
    
    % <num_data> more rows for muscle length
    % read length from alllengths vector
    % and angles from alljnts matrix
    b(ndofs*num_data+1:(ndofs+1)*num_data) = ma.alllengths;

    % generate the npar polynomial terms, and for each term, add a column to A    
    for ipar=1:npar
        help = repmat(polylist(ipar,:),size(ang,1),1);
        A(ndofs*num_data+1:(ndofs+1)*num_data,ipar) = (prod(ang.^help,2));
    end  
        
    fprintf('Total number of data points: %d\n',tot_data);
   
    % now we have all data for this muscle stored in A and b
    
    % solve the full model with npar-1 terms
    p = A\b;		% compute coefficients of the best fitting model
    bpred = A*p;	% these are the moment arms predicted by this model
    res = bpred-b;	% residuals
    RMSfull = (sqrt(sum(res.^2)/tot_data)) * 1000;		% RMS of residuals, in mm
        
    fprintf('RMS fit error of the full model is: %f mm\n',RMSfull);
    fprintf('maximum moment arm: %f mm\n',maxall);
    fprintf('maximum error allowed: %f mm\n',momarm_error);
    fprintf(logfile,'%s\n',mus.name);
    fprintf(logfile,'  RMS fit error of the full model is: %f mm\n',RMSfull);
    fprintf(logfile,'  maximum moment arm: %f mm\n',maxall);
    fprintf(logfile,'  maximum error allowed: %f mm\n',momarm_error);

    % now do stepwise regression to select polynomial terms for a smaller model
    Aselected = [];
    polylist_selected = [];
    npar_selected = 0;
    % outer loop: successively add columns to Aselected
    for i = 1:npar-1
        [~, ncolumns] = size(A);
        % inner loop: find the column of A that causes most reduction in RMS when added to Aselected
        RMSnew = zeros(1,ncolumns); % this will store the RMS errors of each expanded model
        for j = 1:ncolumns
            % add column j from A to Anew
            Anew = [Aselected A(:,j)];
            % solve new p's
            pnew = Anew\b;
            % compute new RMS fit error
            RMSnew(j) = (norm(Anew*pnew - b)/(sqrt(tot_data))) * 1000; 	% convert to mm
        end
        % now determine which expanded model had the lowest RMS
        [RMSmin, col] = min(RMSnew);
        % if the change in error is less than 5%, stop without adding this term
       % if ((i>1)&&((RMS - RMSmin)/RMS<0.01))
        if ((i>1)&&((RMS - RMSmin)/RMS<0.05))
            fprintf('Change in error: %3f. No more terms added.\n ',(RMS - RMSmin)/RMS);
            fprintf(logfile,'Change in error: %3f. No more terms added.\n ',(RMS - RMSmin)/RMS);
            break;
        end
        % otherwise add this column to Aselected
        Aselected = [Aselected A(:,col)];
        npar_selected = npar_selected + 1;
        p = Aselected\b;		% solve the coefficients (again)
        % compute some error measures
        SSE = sum((Aselected*p-b).^2); 			% summed squared errors (SSE)
        RMS = (sqrt(SSE/tot_data)) * 1000; 			% RMS error, is the same as what we had before
        GCV = SSE/((num_data - npar_selected)^2);    	% Generalized Cross Validation
        AIC = log(SSE) + 2*npar_selected/tot_data;   	% Akaike's Information Criterion
        % print what we just did, on screen and on output file
        fprintf('Model addition step %3i: Added term ',i);
        fprintf('%i ',polylist(col,:));
        fprintf('-- RMS=%6.2f, GCV=%8.3e, AIC = %6.2f\n',RMS,GCV,AIC);
        fprintf(logfile,'  Model addition step %3i: Added term ',i);
        fprintf(logfile,'%i ',polylist(col,:));
        fprintf(logfile,'-- RMS=%f, GCV=%e, AIC = %f\n',RMS,GCV,AIC);

        % remember the exponents of this polynomial term
        polylist_selected = [polylist_selected ; polylist(col,:)];
        % remove this column from A and from polylist so it is not used again
        A = [A(:,1:(col-1)) A(:,(col+1):ncolumns)];
        polylist = [polylist(1:(col-1),:);polylist((col+1):ncolumns,:)];
        % stop adding terms if RMS error in fvectors is less than
        % momarm_error
        if ((RMS<=momarm_error))
            break;
        end
    end 		% and go find the next term

    % save muscle model in structure mus_model
    mus_model{imus}.name = mus.name;
    mus_model{imus}.num_lparams = npar_selected;
    mus_model{imus}.lparams = polylist_selected; % size of lparams: num_lparams x num_dofs
    mus_model{imus}.lcoef = p;
    
    % save muscle models in .mat file
    save(matfilename,'mus_model');
    
    % write this muscle's model in the output text file
    fprintf(polyfile,mus.name);
    fprintf(polyfile,'\nparameters %d\n',npar_selected);
    fprintf(polyfile,'# exponents ... coefficient\n');
    for i = 1:npar_selected
        fprintf(polyfile,'\t');
        fprintf(polyfile,'%3d ',polylist_selected(i,:));
        fprintf(polyfile,'   %10.5e \n', p(i));
    end
    fprintf(logfile,'  %d polynomial terms were written for %s\n',npar_selected+1, mus.name);

    % plot muscle length from Opensim and polynomial
    % if ~mod(imus,15)
    %     examine_momarms(mus_model{imus}, mus.dof_names, ma.allmomarms, ang);	
    % end
    
    clear ma A b ang;
    
end 		% go process next muscle

fclose(polyfile);
fclose(logfile);

end